<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CoSSA hands-on 2020</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h2 id="table-of-contents">Table of contents</h2>
<ul>
<li>
<p>step1: Installation of a Linux virtual machine on PC or Laptop</p>
</li>
<li>
<p>step2: Setting up the CoSSA pipeline</p>
</li>
<li>
<ul>
<li>Create conda environment CoSSA</li>
</ul>
</li>
<li>
<ul>
<li>Installing the CoSSA software tools</li>
</ul>
</li>
<li>
<ul>
<li>Downloading CoSSA scripts and toy data</li>
</ul>
</li>
<li>
<p>step3: Running CoSSA</p>
</li>
</ul>
<h2 id="installation-of-a-linux-virtual-machine-on-pc-or-laptop">Installation of a Linux virtual machine on PC or Laptop</h2>
<p><strong>How to install Windows Subsystem for Linux using Settings</strong></p>
<p>If you want to run distributions of Linux on Windows 10, you must first enable the Windows Subsystem for Linux feature before you can download and install the flavor of Linux that you want to use.</p>
<p><strong>Enabling Windows Subsystem for Linux using Settings</strong></p>
<p>To install WSL using Setting on Windows 10, use these steps:</p>
<p>Open <strong>Settings</strong>.</p>
<p>Click on <strong>Apps</strong>.</p>
<p>Under the “Related settings” section, click the <strong>Programs and Features</strong> option.<br>
<a href="https://postimg.cc/LhWGCfgt"><img src="https://i.postimg.cc/CLMYKsFQ/Co-SSA-fig1.jpg" alt="Co-SSA-fig1.jpg"></a></p>
<p>Click the <strong>Turn Windows features on or off</strong> option from the left pane.</p>
<p><img src="https://i.postimg.cc/W4m5QY94/Co-SSA-fig2.jpg" alt="Co-SSA-fig2.jpg"></p>
<p>Check the <strong>Windows Subsystem for Linux</strong> option.</p>
<p><a href="https://postimg.cc/6yGgD3CD"><img src="https://i.postimg.cc/TYkx551Y/Co-SSA-fig3.jpg" alt="Co-SSA-fig3.jpg"></a></p>
<p>Click the <strong>OK</strong> button.</p>
<p>Click the <strong>Restart now</strong> button.</p>
<p>Once you complete the steps, the environment will be configured to download and run the distros of Linux on Windows 10.</p>
<p><strong>Installing Linux distros using Microsoft Store</strong></p>
<p>To install a distribution of Linux on Windows 10, use these steps:</p>
<p>Open <strong>Microsoft Store</strong>.</p>
<p>Search for the Linux distribution that you want to install.</p>
<p>Select Ubuntu and <strong>Get</strong> it.<br>
<a href="https://postimg.cc/TLynhPMn"><img src="https://i.postimg.cc/26GGcq09/Co-SSA-fig4.jpg" alt="Co-SSA-fig4.jpg"></a><br>
Once the software is downloaded you have to <strong>LAUNCH</strong> the server.<br>
It takes a few minutes before  your Linux virtual machine is installed and will be completed after:</p>
<pre><code>enter a new UNIX username:vm-ubuntu
New password:plantbreeding
Retype new password:plantbreeding
</code></pre>
<p>Here we are, you have created a linux virtual environment and have a terminal open in which you can type or copy/paste the CoSSA pipeline commands.</p>
<p>For more info about the installation of linux virtual machines go to:<br>
<a href="https://www.windowscentral.com/install-windows-subsystem-linux-windows-10">https://www.windowscentral.com/install-windows-subsystem-linux-windows-10</a></p>
<h2 id="setting-up-the-cossa-pipeline">Setting up the CoSSA pipeline**</h2>
<p><strong>Create conda environment CoSSA</strong></p>
<p>A convenient tool for the installation of software packages and setting up pipelines in Linux are the so called <a href="https://docs.conda.io/projects/conda/en/latest/index.html">conda</a> environments. The CoSSA conda environment will contain all the tools needed for running the pipeline. First you have to check if conda is already installed.</p>
<p>On the command line of the linux terminal type:</p>
<pre><code>conda --version
</code></pre>
<p>If this commands returns the message <code>-bash: conda: command not found</code>  you have to install it first.<br>
Miniconda is a free minimal installer of conda. It is a small, bootstrap version of Anaconda that includes only conda, python, the packages they depend on, and a small number of other useful packages.</p>
<p>On the command line type or copy/paste (right mouse click = paste)</p>
<pre><code>wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
</code></pre>
<p>The Miniconda3 package is downloaded and ready to install using the Unix shell and command language bash. You can have a look if it is there by typing the bash command <code>ls</code>,and if it is try the following command line trick:<br>
Type <code>bash</code>, followed by capital <code>M</code> and hit the tab key. As you will notice bash will fill in the file name for you so you don’t have to type the filenames or directory names yourself in bash. Not only very convenient but will also save you a lot of typing errors ;-)</p>
<pre><code>bash Miniconda3-latest-Linux-x86_64.sh
</code></pre>
<p>After three questions/remarks which can all be accepted Miniconda3 will be  installed successfully and they will thank you for that. However there was also the message “=&gt; For changes to take effect, close and re-open your current shell. &lt;==” .<br>
Type on the command line:</p>
<pre><code>exit
</code></pre>
<p>and the Ubuntu terminal will close. Using  the windows start button you  can launch the virtual environment by a <strong>Click</strong> on the Ubuntu app.<br>
Conda should now be available,  so lets try again</p>
<pre><code>conda --version
</code></pre>
<p>We will now create a conda environment specific for the CoSSA workflow</p>
<pre><code>conda create --name CoSSA
</code></pre>
<p>To use a specific conda environment you first have to activate it by</p>
<pre><code>conda activate CoSSA
</code></pre>
<p><img src="https://i.postimg.cc/PJjwndRM/Co-SSA-env.jpg" alt="enter image description here"></p>
<p><strong>Installing the CoSSA software tools</strong><br>
Although it is possible to install the whole pipeline in one go, we will install the tools needed for the pipeline through conda, In this way you will get familiar with conda and can use it as well for install software packages outside the scope of CoSSA. The tools needed for the CoSSA pipeline are:</p>
<p><strong>FastP</strong> – fastq preprocessor for quality control and filtering features</p>
<p><strong>KMC3</strong> – K-mer counter and KMC tools for operations with k-mer databases</p>
<p><strong>BWA</strong> – alignment algorithm for aligning sequence reads against a reference genome</p>
<p><strong>Sambamba</strong> – reading/writing/editing/indexing/viewing bam files</p>
<p><strong>Mosdepth</strong> – Fast BAM depth calculation</p>
<p>Let’s install the software packages using conda:</p>
<pre><code>conda install -c bioconda/label/cf201901 fastp kmc bwa sambamba mosdepth
</code></pre>
<p>And of course we want to proceed:</p>
<pre><code>Proceed ([y]/n)?  y
</code></pre>
<p>A few python packages for plotting the figures are needed as well</p>
<pre><code>conda install numpy pandas matplotlib
</code></pre>
<p>It takes a few minutes but then all the tools needed should have been installed without major error messages.</p>
<p>The tools needed are installed but how to use them ?  Most tools have a build-in help function which shows the usage of the tool, the options for this tool and the default settings of the options. e.g.</p>
<pre><code>fastp --help

kmc --help

kmc_tools --help

sambamba --help

bwa –help

mosdepth --help
</code></pre>
<p><strong>Downloading CoSSA scripts and toy data</strong></p>
<p>The CoSSA pipeline is a set of bash scripts in which data is redirected to the above mentioned tools.  These scripts are freely available, updated and maintained on GitHub. GitHub is a repository hosting service where you can find all kinds of useful, useless and freely available software.<br>
To be able to test the pipeline and to get familiar with CoSSA , a toy data is created. Dataset 1 exists of simulated fastq data of a bulk of resistent samples, a bulk of susceptible samples and a reference chromosome. Dataset 2 consist simulated sequence data of a R-parent, R-bulk, S-parent and S-bulk and also makes use of the same reference chromosome.<br>
To download the scripts and data from the PBR Github repository:</p>
<pre><code>git clone https://github.com/PBR/CoSSA.git
</code></pre>
<p>and type the bash command <code>ls</code> and <code>ls CoSSA</code> on the command line.<br>
<img src="https://i.postimg.cc/yx3nN613/git.jpg" alt="enter image description here"></p>
<p>Instead of storing all data in one place, the data is structured into directories.<br>
The directory CoSSA contains three sub directories. The reference genome sequence is found in directory  <strong>reference</strong>, the sequence reads in directory <strong>rawreads</strong> and the CoSSA scripts in directory <strong>scripts</strong>. Later on after running the scripts of the CoSSA pipeline you will notice that new directories are created by the pipeline. In these directories you will find the result files of the scripts.<br>
Instead of staying in your so called home directory we will go to directory CoSSA from where we will run the scripts</p>
<pre><code>cd CoSSA
</code></pre>
<p>You have used the bash commands <code>ls</code> and <code>cd</code> on the command line, but there are much more bash commands available which you can and will use when using the Linux command line. <a href="https://courses.cs.washington.edu/courses/cse391/17sp/bash.html">Here</a>. you can find a complete list of the available bash commands.</p>
<h2 id="running-the-cossa-pipeline">Running the CoSSA pipeline</h2>
<p>The CoSSA pipeline contains general and sample specific analysis. The general analysis like read quality checks, pre-processing of the reads and k-mer counting have to be done for all samples. Instead of running the analysis  for each sample separately the CoSSA pipeline will do this using a loop. To do so you only have to add the name of the sample directory to a text file (e.g. genotypes.list but you can use whatever name) in directory <strong>rawreads</strong> and after running the scripts all the samples in the genotypes.list will have been processed.</p>
<p>The tool <a href="https://www.howtogeek.com/howto/42980/the-beginners-guide-to-nano-the-linux-command-line-text-editor/">nano</a> is an easy to use linux command line text editor which you can use to create a file like genotypes.list.</p>
<p>On the command line type</p>
<pre><code>nano rawreads/genotypes.list
</code></pre>
<p>The file genotypes.list was already created and the sample names, one sample per line,  were already added to this file</p>
<p>CoSSA_toy1<br>
CoSSA_toy2</p>
<p>After adding all samples which you want to process, e.g the samples of dataset2, save and close the file<br>
<code>Ctrl x</code> followed by <code>y(es)</code></p>
<p><strong>Bash scripts</strong></p>
<p>The CoSSA pipeline steps are executed on the server in a so called bash script. Bash reads the lines, one line at the time and interpreted and execute these lines as if they would have come directly from the keyboard (as you have be doing by typing nano) If the text in a bash script is commented (# in front of the word or sentence) the line is not executed. Usage of the bash scripts can be invoked by the <code>–help</code> function. If you’re interested in to see how a bash script looks like you can use the command <code>less scripts/CoSSA_fastp_reads.sh</code>. You quit reading the file by typing <code>q</code> (q=quit).<br>
The naming of the scripts is as follows:</p>
<p>scripts/			— path to the script<br>
CoSSA_			— scripts developed for CoSSA<br>
tool name_		— the tool which is called inside the script<br>
data type		— which type of data as input	<br>
.sh					— extension for bash</p>
<p>As an example: scripts/CoSSA_fastp_reads.sh will run the tool fastp with reads as input but will throw an error if k-mer tables are used as input.</p>
<p><strong>Quality check and pre-processing of sequence reads</strong></p>
<p>Quality control and pre-processing of sequencing data are critical to obtaining high-quality and high-confidence variants in downstream data analysis. Data can suffer from adapter contamination, base content biases and over represented sequences. Fastp is a tool to provide fast all-in-one pre-processing of FASTQ files.The sequence quality of most sequence providers is already of high quality so we will do a quick quality check for one million read pairs and based on the results decide if analysis and trimming of the whole data set is required. The scripts needs two arguments, the list with samples to process and the number of reads to analyze</p>
<pre><code>bash scripts/CoSSA_fastp_reads.sh genotypes.list 100000
</code></pre>
<p>As you will have noticed you already get some info about the quality on the screen but  the folder <strong>fastp</strong>  contains more info.</p>
<pre><code>ls rawreads/CoSSA_toy1/fastp/
</code></pre>
<p>You will find two sequence files containing the quality filtered and trimmed sequences but  there is also a fastp report made in html format which can be viewed using a browser. (If you are using a Linux server instead of the installed virtual machine use command <code>firefox rawreads/CoSSA_toy1/fastp/CoSSA_toy1_fastp.html</code>) On the command line type or copy/paste:</p>
<pre><code>python3 -m http.server 8000
</code></pre>
<p>Next, copy/paste  <code>[http://localhost:8000/]</code> in the address bar of your browser (Microsoft Edge, Chrome, Firefox etc.) and navigate to the html file (rawreads/CoSSA_toy1/fastp/CoSSA_toy1_fastp.html] and <strong>Click</strong> on the file (or use this link <a href="http://localhost:8000/rawreads/CoSSA_toy1/fastp/CoSSA_toy1_fastp.html">http://localhost:8000/rawreads/CoSSA_toy1/fastp/CoSSA_toy1_fastp.html</a>)<br>
All the information generated by the tool is now visualized in the browser.<br>
You can do the same for CoSSA_toy2. (or use this link <a href="http://localhost:8000/rawreads/CoSSA_toy2/fastp/CoSSA_toy2_fastp.html">http://localhost:8000/rawreads/CoSSA_toy2/fastp/CoSSA_toy2_fastp.html</a>)</p>
<p>After inspection of the data we have to decide if it is necessary to filter and trim the sequence data. Filtering a full dataset comes at a cost, the computational time of the CoSSA pipeline will increase substantially but the gained increase in the data quality is often negligible. However, if you decide to use a filtered set, you have to adjust the path of the reads files in the genotype.list<br>
To continue the pipeline we have to go back to the command line. In most cases using <strong>Ctrl+C</strong> will do the trick.</p>
<p><strong>K-mer counting</strong></p>
<p>KMC3 is a memory efficient and fast algorithm for generating k-mer tables for sequence reads and comes with the kmc_tools suite for manipulating of these k-mer tables<br>
The script for counting k-mers makes also use of a loop structure  and it needs a list of samples to process as an argument:</p>
<pre><code>bash scripts/CoSSA_kmc3_count_kmers_reads.sh genotypes.list
</code></pre>
<p>The scripts creates a new directory kmc within the sample directory which contains all the output files. Beside the unreadable binary k-mer table also a histogram file is created in the directory kmc. e.g CoSSA_toy1.kmc3.histo. This file contains the kmer frequency distribution of the sample reads:</p>
<pre><code>less rawreads/CoSSA_toy1/kmc/CoSSA_toy1.kmc3.histo
</code></pre>
<p>This file is also used for plotting a simple k-mer profile (rawreads/CoSSA_toy1/kmc/CoSSA_toy1.kmc3.histo.png).<br>
To view this file  type on the command line</p>
<pre><code>python3 -m http.server 8000
</code></pre>
<p>and go to <a href="http://localhost:8000">http://localhost:8000</a> and navigate to the .png file</p>
<p>A more  advanced analysis of the k-mer statistics is done by the online tool of <a href="http://qb.cshl.edu/genomescope/genomescope2.0/">Genomescope2</a> .  There you can upload a kmer histo file and run the analysis. We will copy the CoSSA_toy1.kmc3.histo file to the windows environment and upload the file from there to Genomescope2;</p>
<pre><code>cat rawreads/CoSSA_toy1/kmc/CoSSA_toy1.kmc3.histo
</code></pre>
<p>Select the content of the file using the left mouse button<br>
copy <strong>Ctrl+C</strong><br>
and paste <strong>Ctrl +V</strong> the content in Notepad and save the file as CoSSA_toy1.kmc3.histo<br>
Do the same for CoSSA_toy2.</p>
<p>The CoSSA_toy1.kmc3.histo file is now copied to your windows environment.<br>
Start <a href="%28http://qb.cshl.edu/genomescope/genomescope2.0/">Genomescope2</a>, upload the histo file(s) and have a look  at the kmer profiles.<br>
Indeed, it is a bit cumbersome to get the data to Genomescope2 but that has to do with the setup of this hands-on virtual environment. On the plantbreeding server the .histo file can be directly uploaded to Genomescope2.</p>
<p><img src="https://i.postimg.cc/j5y1fXdD/Challenger.png" alt="enter image description here"><br>
Fig1: k-mer profile of a real data set of a tetraploid potato cultivar</p>
<p><strong>K-mer table manipulations using kmc_tools</strong></p>
<p>In the CoSSA paper a part of the strategy is to subtract the k-mers from the susceptible bulk  from the k-mers from the resistent bulk to obtained resistent bulk specific k-mers.<br>
The CoSSA pipeline has a few scripts to play around with k-mer tables. Note that these scripts can be easily be adapted to your needs by changing parameters within the script using nano. The scripts needs as arguments the two names of the k-mer tables which you want to use.</p>
<p>Subtraction of k-mer tables:</p>
<pre><code>bash scripts/CoSSA_kmc3_subtract_kmers.sh rawreads/CoSSA_toy1/kmc/CoSSA_toy1 rawreads/CoSSA_toy2/kmc/CoSSA_toy2
</code></pre>
<p>Intersection of k-mer tables can be made by:</p>
<pre><code>bash scripts/CoSSA_kmc3_intersect_kmers.sh rawreads/CoSSA_toy1/kmc/CoSSA_toy1 rawreads/CoSSA_toy2/kmc/CoSSA_toy2
</code></pre>
<p>For combining k-mer table of samples you can use the script CoSSA_kmer_union.sh</p>
<p>See the <a href="http://sun.aei.polsl.pl/kmc">manual</a> of kmc_tools for all the options.<br>
The result files of the different scripts are stored in a newly created directory and can be viewed by:</p>
<pre><code> ls k-mer_manipulations 
</code></pre>
<p><strong>Advanced filtering options</strong></p>
<p>Using a kmer frequency plot generated by Genomescope2 or CoSSA, coverage cut off values can be determined for several reasons. The lower cut off eliminates error sequences Note that the k-mers with frequency 1 were already removed from the k-mer tables, but maybe a higher threshold is needed. The high cut off values eliminates k-mers from multiple copy regions that you may not want to be included in your analysis. Besides these cut offs also thresholds can be set for selecting specific ploidy k-mers, e.g unique k-mers (simplex) or the duplex, triplex etc  k-mers. Thresholds could be defined as the 5th and 95th percentile of the coverage median (median coverage  x -1.645 and median coverage x 1.645)</p>
<p><strong>Aligning selected k-mers to a reference genome</strong></p>
<p>When you have made selections of k-mers using these k-mer scripts and you probably want to know where these k-mers will align on a genome of interest. Therefore you will need a reference genome sequence. For the toy example there is already a reference sequence available in the directory <strong>reference</strong> e.g chr11.fa.</p>
<p>However , if you need other reference sequences and you know were to get it e.g. at <a href="https://www.ncbi.nlm.nih.gov/genome">NCBI</a> or in case of the potato genome of Solyntus at  <a href="https://www.plantbreeding.wur.nl/Solyntus/">https://www.plantbreeding.wur.nl/Solyntus/</a> you can download the sequences to the directory <strong>reference</strong>.<br>
In general a genome sequence file is a compressed file and you first have to decompress the file to a fasta file before you can use it:</p>
<pre><code>tar zxvf Solyntus_v1.1.fasta.tar.gz
</code></pre>
<p>To be able to use a genome sequence for aligning the original reads or k-mers  the BWA alignment tool makes use of an index which has to  created just once for each genome.<br>
Here we will use the already decompressed reference file chr11.fa.</p>
<pre><code>bash scripts/CoSSA_bwaindex_genome.sh reference/chr11.fa
</code></pre>
<p>Next the extracted k-mer set can be aligned to the reference sequence</p>
<pre><code>bash scripts/CoSSA_bwasamse_kmers.sh reference/chr11.fa k-mer_manipulations/CoSSA_toy1.CoSSA_toy2.subtract
</code></pre>
<p>If not already present a new directory bamfiles is created  and the alignment file, a so called <a href="https://en.wikipedia.org/wiki/SAM_%28file_format%29">bam</a> file is stored in here. The next step is to identify the regions on the chromosomes were the selected k-mers are aligned. This is done by the tool mosdepth which takes the bamfile as an argument.</p>
<pre><code>bash scripts/CoSSA_mosdepth_bam.sh bamfiles/CoSSA_toy1.CoSSA_toy2.subtract.bam
</code></pre>
<p>This command shows in the terminal the k-mer distribution over the first 20 bins of 1kb of chr11. The command <code>ls bamfiles</code>lists all the create files in the bamfiles directory including a .png file. This file shows the k-mer distribution over the whole chromosome . To have a look copy/paste <code>localhost:8000</code> in the browser address bar , navigate to the file and <strong>Click</strong> on it.  For this hands-on we zoomed into the region of interest, instead of showing the whole chromosome.<br>
In real life you’re probably more interested in the k-mer distribution over a whole genome. In the next figure you see such an example as the result of the CoSSA workflow with k-mer peaks on chr1 en chr9</p>
<p><img src="https://i.postimg.cc/fWxJ5fDr/kmerdistribution-potato.jpg" alt="enter image description here"></p>
<p>With the above examples of how to use the CoSSA scripts and have an idea about the results to expect, you can start your own CoSSA strategy using the other datasets which are available in the rawreads directory. You could for instance follow the strategy as described in the CoSSA paper  according to the following flowchart</p>
<p><img src="https://i.postimg.cc/fLzy439r/image009.jpg" alt="enter image description here"></p>
<p>Filtering steps which can be performed on the available datasets using the CoSSA scripts are e.g:</p>
<ul>
<li>
<p>Rbulk - Sbulk = Rbulk specific k-mers</p>
</li>
<li>
<p>Sbulk - Rbulk = Sbulk specific k-mers</p>
</li>
<li>
<p>Rbulk specific k-mers  Ո  Rbulk = R-bulk specific k-mers in common with Rbulk</p>
</li>
<li>
<p>Rbulk specific k-mers  Ո Sbulk = R-bulk specific k-mers in common with Sbulk</p>
</li>
<li>
<p>Rbulk specific k-mers – R-parent = Rbulk specific k-mers not in R-parent</p>
</li>
<li>
<p>Rbulk specific k-mers – S-parent = Rbulk specific k-mers not in S-parent</p>
</li>
<li>
<p>Rbulk specific k-mers not in R-parent - Rbulk specific k-mers not in S-parent = Rbulk specific k-mers inherited from S-parent</p>
</li>
<li>
<p>Rbulk specific k-mers not in S-parent - Rbulk specific k-mers not in R-parent = Rbulk specific k-mers inherited from R-parent</p>
</li>
<li>
<p>Rbulk specific k-mers not in R-parent - Rbulk specific k-mers in common S-parent = Rbulk specific k-mers inherited from none of the parents = sequencing errors and contamination</p>
</li>
<li>
<p>Rbulk specific k-mers in common R-parent  Ո  Rbulk specific k-mers in common S-parent = Rbulk specific k-mers inherited from both parents</p>
</li>
</ul>
<p>The sum of these last 4 k-mer sets = Rbulk specific k-mers.</p>
<p>Maybe you want to know what the intermediate results are of the different filtering steps, want to know how the remaining k-mers look like or to count the number,. You can use the script CoSSA_kmc3_dump_kmers.sh to do so… It takes a kmc library and prints out a readable dump file. To have a look at the k-mers themselves use the command <code>less k-mer_manipulations/&lt;name&gt;.dump</code> To count the number of k-mers you can use the command <code>wc -l k-mer_manipulations/&lt;name&gt;.dump</code><br>
After selecting the specific k-mer sets you can continue with the mapping  and coverage estimation scripts to find the physical position of the k-mers on a genome.</p>
<p>Using a virtual Linux environment is a convenient way to play around with scripts, scripting languages like Python and other Linux related secrets. However, if you are going to use the CoSSA on real data sets you have to switch to a Linux server since you will need more storage space and memory (RAM). The CoSSA Github repository will be updated with scripts and manuals for the CoSSA analysis on the WUR PlantBreeding Server.</p>
<p>Have fun ! and if you have any questions or comments please let us know.</p>
<p>Corentin Clot<br>
Herman van Eck<br>
Reinhard Simon<br>
Danny Esselink<br>
Richard Visser</p>
<p>With acknowledgement to Charlotte Prodhomme, Jack Vossen and Simone Dimitrova.</p>
<blockquote>
<p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote>
</div>
</body>

</html>
